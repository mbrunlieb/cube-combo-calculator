<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Combo Probability Calculator</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/prop-types@15.8.1/prop-types.min.js"></script>
    <script src="https://unpkg.com/recharts@2.8.0/umd/Recharts.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo } = React;
        
        // Access Recharts components from the global Recharts object
        const { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } = window.Recharts || {};

        const MTGComboCalculator = () => {
            const [cardsDrawn, setCardsDrawn] = useState(13);
            const [comboSize, setComboSize] = useState(2);
            const [copiesA, setCopiesA] = useState(1);
            const [copiesB, setCopiesB] = useState(1);
            const [copiesC, setCopiesC] = useState(1);
            const [copiesD, setCopiesD] = useState(1);
            const [mulliganThreshold, setMulliganThreshold] = useState(20);
            const [drawsAfterMulligan, setDrawsAfterMulligan] = useState(6);

            // Hypergeometric probability: P(X >= k) where X is successes in n draws from population N with K successes
            const hypergeometric = (N, K, n, k) => {
                if (k > Math.min(K, n) || k < Math.max(0, n - (N - K))) return 0;
                
                const combinations = (n, r) => {
                    if (r > n || r < 0) return 0;
                    if (r === 0 || r === n) return 1;
                    
                    let result = 1;
                    for (let i = 0; i < Math.min(r, n - r); i++) {
                        result = result * (n - i) / (i + 1);
                    }
                    return result;
                };
                
                return combinations(K, k) * combinations(N - K, n - k) / combinations(N, n);
            };

            // Calculate probability of drawing at least 1 of each combo piece
            const calculateComboProb = (drawn, pieces) => {
                const deckSize = 40;
                
                if (pieces.length === 2) {
                    const [copiesA, copiesB] = pieces;
                    const prob0A = hypergeometric(deckSize, copiesA, drawn, 0);
                    const prob0B = hypergeometric(deckSize, copiesB, drawn, 0);
                    const prob0AAndB = hypergeometric(deckSize, copiesA + copiesB, drawn, 0);
                    return 1 - (prob0A + prob0B - prob0AAndB);
                }
                
                if (pieces.length === 3) {
                    const [copiesA, copiesB, copiesC] = pieces;
                    // Use inclusion-exclusion principle for 3 sets
                    const prob0A = hypergeometric(deckSize, copiesA, drawn, 0);
                    const prob0B = hypergeometric(deckSize, copiesB, drawn, 0);
                    const prob0C = hypergeometric(deckSize, copiesC, drawn, 0);
                    const prob0AB = hypergeometric(deckSize, copiesA + copiesB, drawn, 0);
                    const prob0AC = hypergeometric(deckSize, copiesA + copiesC, drawn, 0);
                    const prob0BC = hypergeometric(deckSize, copiesB + copiesC, drawn, 0);
                    const prob0ABC = hypergeometric(deckSize, copiesA + copiesB + copiesC, drawn, 0);
                    
                    return 1 - (prob0A + prob0B + prob0C - prob0AB - prob0AC - prob0BC + prob0ABC);
                }
                
                if (pieces.length === 4) {
                    const [copiesA, copiesB, copiesC, copiesD] = pieces;
                    // Use inclusion-exclusion principle for 4 sets
                    const prob0A = hypergeometric(deckSize, copiesA, drawn, 0);
                    const prob0B = hypergeometric(deckSize, copiesB, drawn, 0);
                    const prob0C = hypergeometric(deckSize, copiesC, drawn, 0);
                    const prob0D = hypergeometric(deckSize, copiesD, drawn, 0);
                    const prob0AB = hypergeometric(deckSize, copiesA + copiesB, drawn, 0);
                    const prob0AC = hypergeometric(deckSize, copiesA + copiesC, drawn, 0);
                    const prob0AD = hypergeometric(deckSize, copiesA + copiesD, drawn, 0);
                    const prob0BC = hypergeometric(deckSize, copiesB + copiesC, drawn, 0);
                    const prob0BD = hypergeometric(deckSize, copiesB + copiesD, drawn, 0);
                    const prob0CD = hypergeometric(deckSize, copiesC + copiesD, drawn, 0);
                    const prob0ABC = hypergeometric(deckSize, copiesA + copiesB + copiesC, drawn, 0);
                    const prob0ABD = hypergeometric(deckSize, copiesA + copiesB + copiesD, drawn, 0);
                    const prob0ACD = hypergeometric(deckSize, copiesA + copiesC + copiesD, drawn, 0);
                    const prob0BCD = hypergeometric(deckSize, copiesB + copiesC + copiesD, drawn, 0);
                    const prob0ABCD = hypergeometric(deckSize, copiesA + copiesB + copiesC + copiesD, drawn, 0);
                    
                    return 1 - (prob0A + prob0B + prob0C + prob0D 
                                - prob0AB - prob0AC - prob0AD - prob0BC - prob0BD - prob0CD
                                + prob0ABC + prob0ABD + prob0ACD + prob0BCD
                                - prob0ABCD);
                }
                
                return 0;
            };

            // Generate data for cards drawn chart (13-20 cards)
            const cardsDrawnData = useMemo(() => {
                const data = [];
                const pieces = comboSize === 2 ? [copiesA, copiesB] : 
                               comboSize === 3 ? [copiesA, copiesB, copiesC] :
                               [copiesA, copiesB, copiesC, copiesD];
                
                for (let cards = 13; cards <= 20; cards++) {
                    data.push({
                        cards,
                        probability: parseFloat((calculateComboProb(cards, pieces) * 100).toFixed(1))
                    });
                }
                return data;
            }, [comboSize, copiesA, copiesB, copiesC, copiesD]);

            // Generate data for different copy combinations (removing redundant permutations)
            const copyData = useMemo(() => {
                let scenarios = [];
                
                if (comboSize === 2) {
                    scenarios = [
                        { name: '1+1', pieces: [1, 1] },
                        { name: '2+1', pieces: [2, 1] },
                        { name: '2+2', pieces: [2, 2] },
                        { name: '3+1', pieces: [3, 1] },
                        { name: '3+2', pieces: [3, 2] },
                        { name: '3+3', pieces: [3, 3] },
                        { name: '4+1', pieces: [4, 1] },
                        { name: '4+2', pieces: [4, 2] },
                        { name: '4+3', pieces: [4, 3] }
                    ];
                } else if (comboSize === 3) {
                    scenarios = [
                        { name: '1+1+1', pieces: [1, 1, 1] },
                        { name: '2+1+1', pieces: [2, 1, 1] },
                        { name: '2+2+1', pieces: [2, 2, 1] },
                        { name: '2+2+2', pieces: [2, 2, 2] },
                        { name: '3+1+1', pieces: [3, 1, 1] },
                        { name: '3+2+1', pieces: [3, 2, 1] },
                        { name: '3+2+2', pieces: [3, 2, 2] },
                        { name: '3+3+1', pieces: [3, 3, 1] },
                        { name: '3+3+2', pieces: [3, 3, 2] }
                    ];
                } else {
                    scenarios = [
                        { name: '1+1+1+1', pieces: [1, 1, 1, 1] },
                        { name: '2+1+1+1', pieces: [2, 1, 1, 1] },
                        { name: '2+2+1+1', pieces: [2, 2, 1, 1] },
                        { name: '2+2+2+1', pieces: [2, 2, 2, 1] },
                        { name: '2+2+2+2', pieces: [2, 2, 2, 2] },
                        { name: '3+1+1+1', pieces: [3, 1, 1, 1] },
                        { name: '3+2+1+1', pieces: [3, 2, 1, 1] },
                        { name: '3+2+2+1', pieces: [3, 2, 2, 1] },
                        { name: '3+3+1+1', pieces: [3, 3, 1, 1] }
                    ];
                }
                
                return scenarios.map(scenario => ({
                    ...scenario,
                    probability: (calculateComboProb(cardsDrawn, scenario.pieces) * 100).toFixed(1)
                }));
            }, [cardsDrawn, comboSize]);

            // Calculate mulligan scenarios
            const mulliganData = useMemo(() => {
                const pieces = comboSize === 2 ? [copiesA, copiesB] : 
                               comboSize === 3 ? [copiesA, copiesB, copiesC] :
                               [copiesA, copiesB, copiesC, copiesD];
                
                // Calculate probability of having combo in opening 7 cards
                const openingProb = calculateComboProb(7, pieces) * 100;
                
                // Calculate expected probability with mulligan strategy
                const calculateMulliganExpectedValue = () => {
                    let expectedValue = 0;
                    let remainingProbability = 1;
                    
                    // Check each mulligan scenario
                    for (let mulligans = 0; mulligans <= 3; mulligans++) {
                        const handSize = 7 - mulligans;
                        if (handSize < 4) break; // Stop at unreasonably small hands
                        
                        // Probability of combo in this hand size + draws
                        const totalCards = handSize + drawsAfterMulligan;
                        const handProb = calculateComboProb(totalCards, pieces) * 100;
                        
                        if (mulligans === 0) {
                            // First hand - keep if above threshold
                            if (openingProb >= mulliganThreshold) {
                                expectedValue += remainingProbability * handProb;
                                remainingProbability = 0;
                                break;
                            } else {
                                // Mulligan - probability we don't keep this hand
                                remainingProbability *= (100 - openingProb) / 100;
                            }
                        } else {
                            // Subsequent hands - simplified model
                            if (handProb >= mulliganThreshold || mulligans === 3) {
                                expectedValue += remainingProbability * handProb;
                                break;
                            } else {
                                remainingProbability *= (100 - handProb) / 100;
                            }
                        }
                    }
                    
                    return expectedValue;
                };
                
                const scenarios = [
                    { name: 'No Mulligan', handSize: 7, totalCards: 7 + drawsAfterMulligan },
                    { name: '1 Mulligan', handSize: 6, totalCards: 6 + drawsAfterMulligan },
                    { name: '2 Mulligans', handSize: 5, totalCards: 5 + drawsAfterMulligan },
                    { name: '3 Mulligans', handSize: 4, totalCards: 4 + drawsAfterMulligan },
                ];
                
                const data = scenarios.map(scenario => ({
                    ...scenario,
                    probability: (calculateComboProb(scenario.totalCards, pieces) * 100).toFixed(1)
                }));
                
                // Add expected value with optimal strategy
                data.push({
                    name: `Optimal Strategy (${mulliganThreshold}% threshold)`,
                    handSize: 'varies',
                    totalCards: 'varies',
                    probability: calculateMulliganExpectedValue().toFixed(1)
                });
                
                return data;
            }, [comboSize, copiesA, copiesB, copiesC, copiesD, mulliganThreshold, drawsAfterMulligan]);

            const currentPieces = comboSize === 2 ? [copiesA, copiesB] : 
                                 comboSize === 3 ? [copiesA, copiesB, copiesC] :
                                 [copiesA, copiesB, copiesC, copiesD];
            const currentProb = calculateComboProb(cardsDrawn, currentPieces);

            // Check if Recharts loaded properly
            if (!window.Recharts || !LineChart) {
                return (
                    <div className="p-6 max-w-6xl mx-auto bg-gray-50 min-h-screen">
                        <h1 className="text-3xl font-bold mb-6 text-center text-gray-800">
                            MTG Combo Probability Calculator
                        </h1>
                        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
                            <strong>Loading Error:</strong> Charts library failed to load. Please refresh the page.
                        </div>
                        <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                            <h2 className="text-xl font-semibold mb-4">Current Scenario (Text Mode)</h2>
                            <div className="text-center">
                                <div className="text-3xl font-bold text-blue-600 mb-2">
                                    {(currentProb * 100).toFixed(1)}%
                                </div>
                                <div className="text-gray-600">
                                    Probability of drawing all {comboSize} combo pieces
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="p-6 max-w-6xl mx-auto bg-gray-50 min-h-screen">
                    <h1 className="text-3xl font-bold mb-6 text-center text-gray-800">
                        MTG Combo Probability Calculator
                    </h1>
                    
                    <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                        <h2 className="text-xl font-semibold mb-4">Current Scenario</h2>
                        <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
                            <div>
                                <label className="block text-sm font-medium mb-2">Combo Size</label>
                                <select
                                    value={comboSize}
                                    onChange={(e) => setComboSize(parseInt(e.target.value))}
                                    className="w-full p-2 border rounded-md"
                                >
                                    <option value={2}>2 Cards</option>
                                    <option value={3}>3 Cards</option>
                                    <option value={4}>4 Cards</option>
                                </select>
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-2">Cards Drawn</label>
                                <input
                                    type="number"
                                    value={cardsDrawn}
                                    onChange={(e) => setCardsDrawn(parseInt(e.target.value) || 13)}
                                    min="1"
                                    max="40"
                                    className="w-full p-2 border rounded-md"
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-2">Copies of Piece A</label>
                                <input
                                    type="number"
                                    value={copiesA}
                                    onChange={(e) => setCopiesA(parseInt(e.target.value) || 1)}
                                    min="1"
                                    max="10"
                                    className="w-full p-2 border rounded-md"
                                />
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-2">Copies of Piece B</label>
                                <input
                                    type="number"
                                    value={copiesB}
                                    onChange={(e) => setCopiesB(parseInt(e.target.value) || 1)}
                                    min="1"
                                    max="10"
                                    className="w-full p-2 border rounded-md"
                                />
                            </div>
                        </div>
                        
                        {comboSize >= 3 && (
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                <div>
                                    <label className="block text-sm font-medium mb-2">Copies of Piece C</label>
                                    <input
                                        type="number"
                                        value={copiesC}
                                        onChange={(e) => setCopiesC(parseInt(e.target.value) || 1)}
                                        min="1"
                                        max="10"
                                        className="w-full p-2 border rounded-md"
                                    />
                                </div>
                                {comboSize >= 4 && (
                                    <div>
                                        <label className="block text-sm font-medium mb-2">Copies of Piece D</label>
                                        <input
                                            type="number"
                                            value={copiesD}
                                            onChange={(e) => setCopiesD(parseInt(e.target.value) || 1)}
                                            min="1"
                                            max="10"
                                            className="w-full p-2 border rounded-md"
                                        />
                                    </div>
                                )}
                            </div>
                        )}
                        
                        <div className="text-center">
                            <div className="text-3xl font-bold text-blue-600 mb-2">
                                {(currentProb * 100).toFixed(1)}%
                            </div>
                            <div className="text-gray-600">
                                Probability of drawing all {comboSize} combo pieces
                            </div>
                        </div>
                    </div>

                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div className="bg-white rounded-lg shadow-lg p-6">
                            <h2 className="text-xl font-semibold mb-4">Probability vs Cards Drawn</h2>
                            <ResponsiveContainer width="100%" height={300}>
                                <LineChart data={cardsDrawnData}>
                                    <CartesianGrid strokeDasharray="3 3" />
                                    <XAxis dataKey="cards" />
                                    <YAxis label={{ value: 'Probability (%)', angle: -90, position: 'insideLeft' }} />
                                    <Tooltip formatter={(value) => [`${value}%`, 'Probability']} />
                                    <Line type="monotone" dataKey="probability" stroke="#2563eb" strokeWidth={3} />
                                </LineChart>
                            </ResponsiveContainer>
                            <p className="text-sm text-gray-600 mt-2">
                                Shows how probability changes as you see more cards (current: {
                                    comboSize === 2 ? `${copiesA}+${copiesB}` :
                                    comboSize === 3 ? `${copiesA}+${copiesB}+${copiesC}` :
                                    `${copiesA}+${copiesB}+${copiesC}+${copiesD}`
                                } copies)
                            </p>
                        </div>

                        <div className="bg-white rounded-lg shadow-lg p-6">
                            <h2 className="text-xl font-semibold mb-4">Probability vs Copy Count</h2>
                            <div className="grid grid-cols-3 gap-2 text-sm">
                                <div className="font-semibold">Copies</div>
                                <div className="font-semibold">Probability</div>
                                <div className="font-semibold">Improvement</div>
                                {copyData.map((item, index) => (
                                    <React.Fragment key={item.name}>
                                        <div className={JSON.stringify(item.pieces) === JSON.stringify(currentPieces) ? 'font-bold text-blue-600' : ''}>
                                            {item.name}
                                        </div>
                                        <div className={JSON.stringify(item.pieces) === JSON.stringify(currentPieces) ? 'font-bold text-blue-600' : ''}>
                                            {item.probability}%
                                        </div>
                                        <div className="text-gray-600">
                                            {index > 0 ? `+${(parseFloat(item.probability) - parseFloat(copyData[0].probability)).toFixed(1)}%` : '—'}
                                        </div>
                                    </React.Fragment>
                                ))}
                            </div>
                            <p className="text-sm text-gray-600 mt-2">
                                Shows how additional functional copies improve your odds (at {cardsDrawn} cards drawn)
                            </p>
                        </div>
                    </div>

                    <div className="bg-white rounded-lg shadow-lg p-6 mt-6">
                        <h2 className="text-xl font-semibold mb-4">Mulligan Analysis</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div>
                                <label className="block text-sm font-medium mb-2">Mulligan Threshold (%)</label>
                                <input
                                    type="number"
                                    value={mulliganThreshold}
                                    onChange={(e) => setMulliganThreshold(parseInt(e.target.value) || 20)}
                                    min="0"
                                    max="100"
                                    className="w-full p-2 border rounded-md"
                                />
                                <p className="text-xs text-gray-500 mt-1">Mulligan if combo probability is below this %</p>
                            </div>
                            <div>
                                <label className="block text-sm font-medium mb-2">Cards Drawn After Mulligan</label>
                                <input
                                    type="number"
                                    value={drawsAfterMulligan}
                                    onChange={(e) => setDrawsAfterMulligan(parseInt(e.target.value) || 6)}
                                    min="0"
                                    max="15"
                                    className="w-full p-2 border rounded-md"
                                />
                                <p className="text-xs text-gray-500 mt-1">Additional cards drawn after keeping a hand</p>
                            </div>
                        </div>
                        
                        <div className="grid grid-cols-4 gap-2 text-sm">
                            <div className="font-semibold">Scenario</div>
                            <div className="font-semibold">Hand Size</div>
                            <div className="font-semibold">Total Cards</div>
                            <div className="font-semibold">Probability</div>
                            {mulliganData.map((item, index) => (
                                <React.Fragment key={item.name}>
                                    <div className={index === mulliganData.length - 1 ? 'font-bold text-blue-600' : ''}>
                                        {item.name}
                                    </div>
                                    <div className={index === mulliganData.length - 1 ? 'font-bold text-blue-600' : ''}>
                                        {item.handSize}
                                    </div>
                                    <div className={index === mulliganData.length - 1 ? 'font-bold text-blue-600' : ''}>
                                        {item.totalCards}
                                    </div>
                                    <div className={index === mulliganData.length - 1 ? 'font-bold text-blue-600' : ''}>
                                        {item.probability}%
                                    </div>
                                </React.Fragment>
                            ))}
                        </div>
                        <p className="text-xs text-gray-600 mt-2">
                            * Opening 7 probability: {(calculateComboProb(7, currentPieces) * 100).toFixed(1)}%. 
                            Optimal strategy accounts for mulligan decisions based on your threshold.
                        </p>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<MTGComboCalculator />, document.getElementById('root'));
    </script>
</body>
</html>
